
// This file was auto-generated by ML.NET Model Builder. 

using Microsoft.Data.SqlClient;
using Microsoft.ML;
using Microsoft.ML.Data;
using Microsoft.ML.Transforms.TimeSeries;
using MLModel_ConsoleApp1;
internal class Program
{
    private static void Main(string[] args)
    {
        //// Create single instance of sample data from first line of dataset for model input
        //MLModel.ModelInput sampleData = new()
        //{
        //    Date = DateTime.Now.AddDays(50),
        //    StatisticId = 15F,
        //};

        //// Make a single prediction on the sample data and print results
        //MLModel.ModelOutput predictionResult = MLModel.Predict(sampleData);

        //Console.WriteLine("Using model to make single prediction -- Comparing actual CountOfDone with predicted CountOfDone from sample data...\n\n");


        //Console.WriteLine($"Id: {sampleData.Id}");
        //Console.WriteLine($"Date: {sampleData.Date}");
        //Console.WriteLine($"StatisticId: {sampleData.StatisticId}");


        //Console.WriteLine($"\n\nPredicted CountOfDone: {predictionResult.Score}\n\n");
        //Console.WriteLine("=============== End of process, hit any key to finish ===============");

        //// Preparation

        //string rootDir = Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "../../../"));
        //string dbFilePath = Path.Combine(rootDir, "Data", "DailyDemand.mdf");
        //string modelPath = Path.Combine(rootDir, "MLModel.zip");
        //string connectionString = $"Data Source=(LocalDB)\\MSSQLLocalDB;AttachDbFilename={dbFilePath};Integrated Security=True;Connect Timeout=30;";

        //// Commencement

        //MLContext mlContext = new();
        //DatabaseLoader loader = mlContext.Data.CreateDatabaseLoader<ModelInput>();

        //// Data loading

        //string query = "SELECT RentalDate, CAST(Year as REAL) as Year, CAST(TotalRentals as REAL) as TotalRentals FROM Rentals";

        //DatabaseSource dbSource = new(SqlClientFactory.Instance,
        //                                connectionString,
        //                                query);

        //IDataView dataView = loader.Load(dbSource);

        //IDataView firstYearData = mlContext.Data.FilterRowsByColumn(dataView, "Year", upperBound: 1);
        //IDataView secondYearData = mlContext.Data.FilterRowsByColumn(dataView, "Year", lowerBound: 1);

        //// Creating of forecaster

        //SsaForecastingEstimator forecastingPipeline = mlContext.Forecasting.ForecastBySsa(
        //    outputColumnName: "ForecastedRentals",
        //    inputColumnName: "TotalRentals",
        //    windowSize: 7,
        //    seriesLength: 30,
        //    trainSize: 365,
        //    horizon: 7,
        //    confidenceLevel: 0.95f,
        //    confidenceLowerBoundColumn: "LowerBoundRentals",
        //    confidenceUpperBoundColumn: "UpperBoundRentals");

        //// Data Training & tranformation

        //SsaForecastingTransformer forecaster = forecastingPipeline.Fit(firstYearData);

        //// Testing of trained data 

        //Evaluate(secondYearData, forecaster, mlContext);

        //// Reusability

        //TimeSeriesPredictionEngine<ModelInput, ModelOutput> forecastEngine = forecaster.CreateTimeSeriesEngine<ModelInput, ModelOutput>(mlContext);
        //forecastEngine.CheckPoint(mlContext, modelPath);

        //Forecast(secondYearData, 7, forecastEngine, mlContext);

        //==========================================================================================================================================
        // Preparation

        string rootDir = Path.GetFullPath(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "../../../"));
        string modelPath = Path.Combine(rootDir, "MLModel.zip");
        string connectionString = "Data Source=(localdb)\\MSSQLLocalDB;Initial Catalog=prodKeepDb;Integrated Security=True;Connect Timeout=30;Encrypt=False;TrustServerCertificate=True;ApplicationIntent=ReadWrite;MultiSubnetFailover=False";

        // Commencement

        MLContext mlContext = new();
        DatabaseLoader loader = mlContext.Data.CreateDatabaseLoader<MLModel.ModelInput>();

        // Data loading
        int userStatisticId = 15;
        string query = $@"SELECT 
                             Date,
                             CAST(CountOfDone as REAL) as CountOfDone,
                             StatisticId
                          FROM DonePerDays
                          WHERE StatisticId = {userStatisticId}
                          ORDER BY Date desc
        ";
                          

        DatabaseSource dbSource = new(SqlClientFactory.Instance,
                                        connectionString,
                                        query);

        IDataView dataView = loader.Load(dbSource);

        // TODo: make the point - datetime.now. Why reverse signs ? 
        IDataView trainData = mlContext.Data.FilterByCustomPredicate<MLModel.ModelInput>(dataView, x => x.Date >= DateTime.UtcNow.Subtract(new TimeSpan(60, 0, 0, 0)));
        IDataView testData = mlContext.Data.FilterByCustomPredicate<MLModel.ModelInput>(dataView, x => x.Date < DateTime.UtcNow.Subtract(new TimeSpan(60, 0, 0, 0)));

        var p1 = trainData.Preview(10);
        var p2 = testData.Preview(10);
        // Creating of forecaster

        SsaForecastingEstimator forecastingPipeline = mlContext.Forecasting.ForecastBySsa(
            outputColumnName: "PredictedCountOfDones",
            inputColumnName: "CountOfDone",
            windowSize: 7,
            seriesLength: 30,
            trainSize: 365,
            horizon: 7,
            confidenceLevel: 0.95f);

        // Data Training & tranformation

        SsaForecastingTransformer forecaster = forecastingPipeline.Fit(trainData);

        // Testing of trained data 

        Evaluate(testData, forecaster, mlContext);

        // Reusability

        TimeSeriesPredictionEngine<MLModel.ModelInput, MLModel.ModelOutput> forecastEngine = forecaster.CreateTimeSeriesEngine<MLModel.ModelInput, MLModel.ModelOutput>(mlContext);
        forecastEngine.CheckPoint(mlContext, modelPath);

        Forecast(testData, 7, forecastEngine, mlContext);

        Console.ReadKey();
    }

    //private static void Evaluate(IDataView testData, ITransformer model, MLContext mlContext)
    //{
    //    IDataView predictions = model.Transform(testData);

    //    IEnumerable<float> actual = mlContext.Data.CreateEnumerable<ModelInput>(testData, true)
    //        .Select(observed => observed.TotalRentals);
    //    IEnumerable<float> forecast = mlContext.Data.CreateEnumerable<ModelOutput>(predictions, true)
    //        .Select(prediction => prediction.ForecastedRentals[0]);

    //    IEnumerable<float> metrics = actual.Zip(forecast, (actualVal, forecastVal) => actualVal - forecastVal);

    //    float MAE = metrics.Average(err => Math.Abs(err));
    //    double RMSE = Math.Sqrt(metrics.Average(err => Math.Pow(err, 2)));

    //    Console.WriteLine("Evaluation Metrics");
    //    Console.WriteLine("---------------------");
    //    Console.WriteLine($"Mean Absolute Error: {MAE:F3}");
    //    Console.WriteLine($"Root Mean Squared Error: {RMSE:F3}\n");
    //}

    //private static void Forecast(IDataView testData, int horizon, TimeSeriesPredictionEngine<ModelInput, ModelOutput> forecaster, MLContext mlContext)
    //{
    //    ModelOutput forecast = forecaster.Predict();

    //    IEnumerable<string> forecastOutput = mlContext.Data.CreateEnumerable<ModelInput>(testData, reuseRowObject: false)
    //        .Take(horizon)
    //        .Select((ModelInput rental, int index) =>
    //        {
    //            string rentalDate = rental.RentalDate.ToShortDateString();
    //            float actualRentals = rental.TotalRentals;
    //            float lowerEstimate = Math.Max(0, forecast.LowerBoundRentals[index]);
    //            float estimate = forecast.ForecastedRentals[index];
    //            float upperEstimate = forecast.UpperBoundRentals[index];
    //            return $"Date: {rentalDate}\n" +
    //            $"Actual Rentals: {actualRentals}\n" +
    //            $"Lower Estimate: {lowerEstimate}\n" +
    //            $"Forecast: {estimate}\n" +
    //            $"Upper Estimate: {upperEstimate}\n";
    //        });

    //    Console.WriteLine("Rental Forecast");
    //    Console.WriteLine("---------------------");
    //    foreach (string prediction in forecastOutput)
    //    {
    //        Console.WriteLine(prediction);
    //    }
    //}

    private static void Evaluate(IDataView testData, ITransformer model, MLContext mlContext)
    {
        IDataView predictions = model.Transform(testData);

        IEnumerable<float> actual = mlContext.Data.CreateEnumerable<MLModel.ModelInput>(testData, true)
            .Select(observed => observed.CountOfDone);
        IEnumerable<float> forecast = mlContext.Data.CreateEnumerable<MLModel.ModelOutput>(predictions, true)
            .Select(prediction => prediction.PredictedCountOfDones[0]);

        IEnumerable<float> metrics = actual.Zip(forecast, (actualVal, forecastVal) => actualVal - forecastVal);

        float MAE = metrics.Average(err => Math.Abs(err));
        double RMSE = Math.Sqrt(metrics.Average(err => Math.Pow(err, 2)));

        Console.WriteLine("Evaluation Metrics");
        Console.WriteLine("---------------------");
        Console.WriteLine($"Mean Absolute Error: {MAE:F3}");
        Console.WriteLine($"Root Mean Squared Error: {RMSE:F3}\n");
    }

    private static void Forecast(IDataView testData, int horizon, TimeSeriesPredictionEngine<MLModel.ModelInput, MLModel.ModelOutput> forecaster, MLContext mlContext)
    {
        MLModel.ModelOutput forecast = forecaster.Predict();

        IEnumerable<string> forecastOutput = mlContext.Data.CreateEnumerable<MLModel.ModelInput>(testData, reuseRowObject: false)
            .Take(horizon)
            .Select((MLModel.ModelInput input, int index) =>
            {
                return $"Date: {input.Date}\n" +
                $"StatId: {input.StatisticId}\n" +
                $"Actual Count of Done : {input.CountOfDone}\n" +
                $"Predicted Count of done : {string.Join(',', forecast.PredictedCountOfDones[index])}";

            });

        Console.WriteLine("Count of done Forecast");
        Console.WriteLine("---------------------");
        foreach (string prediction in forecastOutput)
        {
            Console.WriteLine(prediction);
        }
    }
}
